#!/usr/bin/env python2
# Horribly unfinished server-side of SecureCRT's "public key assistant" subsystem.
# Working:
#   - assistant protocol
#   - actual update of user's authorized_keys
#
# http://tools.ietf.org/html/rfc4819
# Data types: http://tools.ietf.org/html/rfc4251#section-5

import os, sys
import tempfile
import struct
import pickle
import yaml

sys.path.append(os.path.expanduser("~/lib/python"))
import authorized_keys as authk

path_openssh = os.path.expanduser("~/.ssh/authorized_keys")
path_yaml = os.path.expanduser("~/securecrt-keys.yaml")

class status:
	SUCCESS					= 0
	ACCESS_DENIED			= 1
	STORAGE_EXCEEDED		= 2
	VERSION_NOT_SUPPORTED	= 3
	KEY_NOT_FOUND			= 4
	KEY_NOT_SUPPORTED		= 5
	KEY_ALREADY_PRESENT		= 6
	GENERAL_FAILURE			= 7
	REQUEST_NOT_SUPPORTED	= 8
	ATTRIBUTE_NOT_SUPPORTED	= 9

statuses = {
	status.SUCCESS:					"Success",
	status.ACCESS_DENIED:			"Access denied",
	status.VERSION_NOT_SUPPORTED:	"Protocol version not supported",
	status.KEY_NOT_FOUND:			"Key not found",
	status.KEY_NOT_SUPPORTED:		"Key type not supported",
	status.KEY_ALREADY_PRESENT:		"Key already present",
	status.GENERAL_FAILURE:			"General failure",
	status.REQUEST_NOT_SUPPORTED:	"Request not supported",
	status.ATTRIBUTE_NOT_SUPPORTED:	"Attribute not supported",
}

KnownAttributes = (
	"comment",
	#"comment-language",
	"command-override",
	#"subsystem",
	"x11",
	"shell",
	"exec",
	"agent",
	#"env",
	"from",
	"port-forward",
	#"reverse-forward",
)

def log(text):
	print >> sys.stderr, text
	sys.stderr.flush()

def openssh_to_attributes(options):
	attrs = []
	for opt, value in options:
		if opt == "command":
			attrs.append({
				"name": "command-override",
				"value": value,
				"critical": True,
			})
		elif opt == "from":
			attrs.append({
				"name": "from",
				"value": value,
				"critical": True,
			})
		elif opt == "no-agent-forwarding":
			attrs.append({
				"name": "agent",
				"value": "",
				"critical": True,
			})
		elif opt == "no-port-forwarding":
			attrs.append({
				"name": "port-forward",
				"value": "",
				"critical": True,
			})
			attrs.append({
				"name": "reverse-forward",
				"value": "",
				"critical": True,
			})
		elif opt == "no-x11-forwarding":
			attrs.append({
				"name": "x11",
				"value": "",
				"critical": True,
			})
		else:
			if value is True:
				value = opt
			else:
				value = "=".join((opt, value))
			attrs.append({
				"name": "x-openssh-option",
				"value": value,
				"critical": False,
			})
	return attrs

def attributes_to_openssh(attrs):
	opts = authk.PublicKeyOptions()
	unparsed = []
	for a in attrs:
		name, value, critical = a["name"], a["value"], a["critical"]
		if name == "agent":
			opts.append(("no-agent-forwarding", True))
		elif name == "command-override":
			opts.append(("command", value))
		elif name == "comment":
			pass
		elif name == "from":
			opts.append(("from", value))
		elif name == "port-forward":
			opts.append(("no-port-forwarding", True))
		elif name == "x11":
			opts.append(("no-x11-forwarding", True))
		elif name == "x-openssh-option":
			if "=" in value:
				opts.append(value.split("=", 1))
			else:
				opts.append((value, True))
		else:
			unparsed.append((critical, name, value))
	return opts, unparsed

def save_keys():
	save_keys_openssh()
	save_keys_yaml()

def load_keys():
	return load_keys_openssh()
	#eturn load_keys_yaml()

def save_keys_yaml():
	fh = open(path_yaml, "wb")
	fh.write("# vim: ft=yaml\n")
	data = []
	for (kalgo, kblob), attrs in keys.items():
		#data.append([kalgo, kblob, attrs])
		data.append(dict(algo=kalgo, key=kblob, attributes=attrs))
	yaml.dump(data, fh)

def load_keys_yaml():
	fh = open(path_yaml, "rb")
	data = yaml.load(fh)
	keys = {}
	#for kalgo, kblob, attrs in data:
	#	keys[kalgo, kblob] = attrs
	for item in data:
		keys[item["algo"], item["key"]] = item["attributes"]
	return keys

def load_keys_openssh():
	keys = {}
	extra_attrs = []
	for line in open(path_openssh, "r"):
		line = line.strip()
		if line and not line.startswith("#"):
			key = authk.PublicKey(line)
			attrs = openssh_to_attributes(key.options)
			if len(key.comment):
				attrs.append({
					"name": "comment",
					"value": key.comment,
					"critical": False,
				})
			attrs += extra_attrs
			extra_attrs = []
			keys[key.algo, key.blob] = attrs
		elif line and line.startswith("# attribute: "):
			# hack to store attributes not supported by authorized_keys
			name, value = line[13:].split("=", 2)
			extra_attrs.append({
				"name": name,
				"value": value,
				"critical": False,
			})
	return keys

def save_keys_openssh():
	fh = open(path_openssh, "w")
	for (kalgo, kblob), attrs in keys.items():
		key = authk.PublicKey()
		key.algo = kalgo
		key.blob = kblob
		for attr in attrs:
			if attr["name"] == "comment":
				key.comment = attr["value"]
		key.options, unsup_attrs = attributes_to_openssh(attrs)

		if len(key.comment):
			fh.write("# %s\n" % key.comment)
		fpr = ":".join("%02x" % ord(c) for c in key.fingerprint())
		print >> fh, "# fprint: %s" % fpr
		for attr in unsup_attrs:
			print >> fh, "# attribute: %(name)s=%(value)s" % attr
		print >> fh, key
		print >> fh, ""

def key_list():
	global keys
	for (kalgo, kblob), attrs in keys.items():
		yield kalgo, kblob, attrs

def key_add(kalgo, kblob, attrs, overwrite=True):
	global keys
	if (kalgo, kblob) in keys and not overwrite:
		return status.KEY_ALREADY_PRESENT
	for attr in attrs:
		if attr["critical"] and attr["name"] not in KnownAttributes:
			return status.ATTRIBUTE_NOT_SUPPORTED
	keys[kalgo, kblob] = attrs
	return status.SUCCESS

def key_remove(kalgo, kblob):
	global keys
	if (kalgo, kblob) in keys:
		del keys[kalgo, kblob]
		return status.SUCCESS
	else:
		return status.KEY_NOT_FOUND

def read_uint32():
	buf = sys.stdin.read(4)
	if not buf:
		raise IOError
	num, = struct.unpack("!L", buf)
	return num

def read_bool():
	buf = sys.stdin.read(1)
	if not buf:
		raise IOError
	val, = struct.unpack("!?", buf)
	return val

def read_string():
	buf = sys.stdin.read(4)
	if not buf:
		raise IOError
	length, = struct.unpack("!L", buf)
	buf = sys.stdin.read(length)
	return buf

def read_packet():
	length = read_uint32()
	name = read_string()
	datalen = length-(4+len(name))
	return name, datalen

def send_packet(*data):
	fmt = "!L"
	outdata = []
	for d in data:
		if isinstance(d, int):
			fmt += "L"
			outdata += [d]
		elif isinstance(d, bool):
			fmt += "?"
			outdata += [d]
		elif isinstance(d, str):
			fmt += "L%ds" % len(d)
			outdata += [len(d), d]
	length = struct.calcsize(fmt)-4
	log("out: %s data[%d]" % (repr(data[0]), length))
	buf = struct.pack(fmt, length, *outdata)
	sys.stdout.write(buf)
	sys.stdout.flush()

def send_status(code):
	msg = statuses.get(code, status.GENERAL_FAILURE)
	send_packet("status", code, msg, "en_US")

def vd_list():
	global keys
	for kalgo, kblob, attrs in key_list():
		data = [kalgo, kblob, len(attrs)]
		for attr in attrs:
			data += attr["name"], attr["value"]
		send_packet("publickey", *data)
	return status.SUCCESS

def vd_add():
	global keys
	kalgo = read_string()
	kblob = read_string()
	overwrite = read_bool()
	num_attrs = read_uint32()
	attrs = []
	while num_attrs:
		attrs.append({
			"name": read_string(),
			"value": read_string(),
			"critical": read_bool(),
		})
		num_attrs -= 1
	return key_add(kalgo, kblob, attrs, overwrite)

def vd_remove():
	kalgo = read_string()
	kblob = read_string()
	return key_remove(kalgo, kblob)

def vd_listattributes():
	for a in KnownAttributes:
		send_packet("attribute", a, False)
	return status.SUCCESS

log_file = tempfile.NamedTemporaryFile(mode="w", prefix="publickey",
	suffix=".log", delete=False)
sys.stderr = log_file

keys = load_keys()

try:
	while True:
		name, datalen = read_packet()
		log("in: %s data[%d]" % (repr(name), datalen))
		if name == "version":
			ver = read_uint32()
			log("version = %d" % ver)
			if ver == 2:
				send_packet("version", 2)
			else:
				send_status(status.VERSION_NOT_SUPPORTED)
				sys.exit()
		elif name == "list":
			send_status(vd_list())
			pass
		elif name == "add":
			send_status(vd_add())
		elif name == "remove":
			send_status(vd_remove())
		elif name == "listattributes":
			send_status(vd_listattributes())
		else:
			log("discarding %d" % datalen)
			sys.stdin.read(datalen)
			send_status(status.REQUEST_NOT_SUPPORTED)
except IOError:
	save_keys()
	log_file.delete = True
	sys.exit()
